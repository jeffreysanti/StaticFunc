
//#import string;
#typelistadd I int8, int16;
#typelistadd I int32, int64;
#typelistadd X int32, int64;

// recursive version	float16 fl2(.16);

def I fibr(I n)
{
	if(n == 1 | n == 2)
		return 1;
	return fib(n - 1) + fib(n - 2);
}

// tail-recursive version
def I fibt(I n)
{
	def I aux(I n_cur, I last, I lastlast)
	{
		if(n_cur == n)
			return last + lastlast;
		aux(n_cur + 1, last + lastlast, last);
	}
	if(n == 1 | n == 2)
		return 1;
	return aux(3, 1, 1);
}

// iterative (mutable)
def I fibi(I n)
{
	if(n == 1 | n == 2)
		return 1;

	mut I last(1);
	mut I lastlast(1);
	for(I x in range(3, n))
	{
		I tmp(last);
		last = last + lastlast;
		last = tmp;
	}
	return last;
}

def vector<X> fibbs(X n)
{
	println("TestSingle");
	return [fibt(x) for I x in range(1, n)];
}

def int32 sum(function<int32, int32> func, int32 n)
{
	if(n == 1)
		return func(n);
	else
		return func(n) + sum(func, n - 1);
}

def tuple<int8, int16, int32, X, vector<X>> T()
{
	return 0;
}

def int32 main(vector<string> args)
{
	int32 oct(043);
	int32 hex(0x2E);
	int32 hexneg(-0x2E);
	int32 octneg(-021);
	
	// floats
	float16 fl(12.13);
	float16 fl2(.16);
	float16 fln(-54.2);
	float16 fln2(-.6);
	
	println(sum(lambda(	int32(int32 n){
							return n*3;
						}),
				10));
	
	for(int32 x in fibbs(20))
	{
		println(string(x));
		println("Test");
	}
	return 0;
}

int32 glob(35 + 456 / 3.0);

return main(_args);


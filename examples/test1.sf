#typelistadd I int8, int16;
#typelistadd I int32, int64;
#typelistadd P2 string, int32;


def int32 dblFunc(int32 x)
{

}

def int32 dblFunc(int32 x)
{

}


// recursive version	float16 fl2(.16);
def I fibr(I n, P2 var)
{
	if(n == 1 | n == 2)
		return 1;
	return fibr(n - 1, var) + fibr(n - 2, var, "hey");
}

// more specfic example
def int32 fibr(int32 n, string var)
{
	println(var);
	if(n == 1 | n == 2)
		return 1;
	return fibr(n - 1, var) + fibr(n - 2, var);
}

// now repeat it
def int32 fibr(int32 n, string var)
{
}



// tail-recursive version
def I fibt(I n)
{
	def I aux(I n_cur, I last, I lastlast)
	{
		if(n_cur == n)
			return last + lastlast;
		aux(n_cur + 1, last + lastlast, last);
	}
	if(n == 1 | n == 2)
		return 1;
	return aux(3, 1, 1);
}

// iterative (mutable)
def I fibi(I n)
{
	if(n == 1 | n == 2)
		return 1;

	mut I last(1);
	mut I lastlast(1);
	for(I x in range(3, n))
	{
		I tmp(last);
		last = last + lastlast;
		last = tmp;
	}
	return last;
}

def vector<I> fibbs(I n)
{
	println("TestSingle");
	return [fibt(x) for I x in range(1, n)];
}

def int32 sum(function<int32, int32> func, int32 n)
{
	if(n == 1)
		return func(n);
	else
		return func(n) + sum(func, n - 1);
}

def tuple<int8, int16, int32, I, vector<I>> T()
{
	//return [2, 4, 5, 3, [3, 1,3]]; // Will be an error in semantic analysis stage
}


def int32 main(vector<string> args)
{
	int32 oct(043);
	int32 hex(0x2E);
	int32 hexneg(-0x2E);
	int32 octneg(-021);
	
	// floats
	float16 fl(12.13);
	float16 fl2(.16);
	float16 fln(-54.2);
	float16 fln2(-.6);
	
	println(sum(lambda(	int32(int32 n){
							return n*3;
						}),
				10));
	
	for(int32 x in fibbs(20))
	{
		println(string(x));
		println("Test");
	}
	return 0;
}

def int32 main2(int32 par1){
	println(string(par1));
	println(string(glob));
	println(string(fibr(par1, 2)));
	int64 res(fibi(par1));
	return par1;
}

vector<int16> v;
int32 glob(35 + 456 / 3);

if(glob == 2){
	println("YES");
}else{
	println("NO");
}

fibr(43, "h");

//return main2(glob);
T();
return 4 + 2 * fibi(7);


dict<string, string> mydict(["a":"the", "b":"cat", "c":"in"]);
dict<int8, int8> mydict2([ci:2*ci for int8 ci in [0,1,2,3,4,5] where ci % 2 == 0]);

dict<int8, string> testmap([s:string(s) for int8 s in range(0, 100)]);

tuple<string:a, int16:b> mytuple2(["the", 5]);

vector<string> myarray(["the", "cat", "in"]);
vector<int8> myarray2([2*ci for int8 ci in range(0,3)]);


